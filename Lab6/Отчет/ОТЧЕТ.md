# Отчет по лабораторной работе 6
#  Деревья. Бинарные деревья поиска

**Дата:** 2025-10-06
**Семестр:** 3 курс 1 полугодие - 5 семестр
**Группа:** ПИЖ-Б_О-23-1(2)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Проценко Дмитрий Максимович

## Цель работы
Цель работы: Изучить древовидные структуры данных, их свойства и применение. Освоить основные
операции с бинарными деревьями поиска (BST). Получить практические навыки реализации BST на
основе узлов (pointer-based), рекурсивных алгоритмов обхода и анализа их эффективности.
Исследовать влияние сбалансированности дерева на производительность операций.

## Теоретическая часть

- Дерево: Рекурсивная структура данных, состоящая из узлов, где каждый узел имеет значение и ссылки на дочерние узлы.
- Бинарное дерево поиска (BST): Дерево, для которого выполняются следующие условия:
    - Значение в левом поддереве любого узла меньше значения в самом узле.
    - Значение в правом поддереве любого узла больше значения в самом узле.
    - Оба поддерева являются бинарными деревьями поиска.
- Основные операции BST:
    - Вставка (Insert): Сложность: в среднем O(log n), в худшем (вырожденное дерево) O(n).
    - Поиск (Search): Сложность: в среднем O(log n), в худшем O(n).
    - Удаление (Delete): Сложность: в среднем O(log n), в худшем O(n). Имеет три случая: удаление листа, узла с одним потомком, узла с двумя потомками.
    - Обход (Traversal):
        - In-order (левый-корень-правый): Посещает узлы в порядке возрастания. Сложность O(n).
        - Pre-order (корень-левый-правый): Полезен для копирования структуры дерева. Сложность O(n).
        - Post-order (левый-правый-корень): Полезен для удаления дерева. Сложность O(n).
- Сбалансированные деревья: Деревья с контролем высоты (например, AVL, Красно-черные), которые гарантируют время операций O(log n) даже в худшем случае.


Для проведения тестов использовался апарат со следующими комплектующими:
Характеристики ПК для тестирования:
- Процессор: Intel Core i7-12700H @ 2.30GHz
- Оперативная память: 16 GB DDR4
- ОС: Windows 11
- Python: 3.13.1

## Практическая часть

1. Реализовать бинарное дерево поиска на основе узлов с основными операциями.
2. Реализовать различные методы обхода дерева (рекурсивные и итеративные).
3. Реализовать дополнительные методы для работы с BST.
4. Провести анализ сложности операций для сбалансированного и вырожденного деревьев.
5. Визуализировать структуру дерева.

### Ключевые фрагменты кода

~~~ python

~~~

## Результаты выполнения

### Пройденные тесты программы

test_delete_leaf_node (__main__.TestBinarySearchTree.test_delete_leaf_node)
Удаление листового узла ... ok
test_delete_node_with_one_child (__main__.TestBinarySearchTree.test_delete_node_with_one_child)
Удаление узла с одним потомком ... ok
test_delete_node_with_two_children (__main__.TestBinarySearchTree.test_delete_node_with_two_children)
Удаление узла с двумя потомками ... ok
test_height (__main__.TestBinarySearchTree.test_height)
Проверка высоты дерева ... ok
test_inorder_traversal_sorted (__main__.TestBinarySearchTree.test_inorder_traversal_sorted)
In-order traversal должен возвращать отсортированный список ... ok
test_insert_and_search (__main__.TestBinarySearchTree.test_insert_and_search)
Тест вставки и поиска ... ok

----------------------------------------------------------------------
Ran 6 tests in 0.002s

### Пример работы программы


## Ответы на контрольные вопросы

1. Сформулируйте основное свойство бинарного дерева поиска (BST).

Основное свойство BST:

Для любого узла N:
- Все ключи в левом поддереве N меньше ключа N.
- Все ключи в правом поддереве N больше ключа N.
- Это свойство рекурсивно выполняется для всех поддеревьев.

2. Опишите алгоритм вставки нового элемента в BST. Какова сложность этой операции в
сбалансированном и вырожденном дереве?

Алгоритм вставки:

1. Начать с корня дерева.
2. Сравнить ключ нового элемента с ключом текущего узла:
    - Если ключ меньше → идем в левое поддерево.
    - Если ключ больше → идем в правое поддерево.
3. Повторять шаг 2 рекурсивно до тех пор, пока не найдем пустое место (None) для вставки.
4. Вставить элемент в найденное место.

Сложность операции:
- Сбалансированное дерево:
    - Высота дерева h ≈ log₂(n)
    - Вставка выполняется за O(log n)
- Вырожденное дерево (например, все элементы добавляются по возрастанию):
    - Высота дерева h ≈ n
    - Вставка выполняется за O(n)

3. Чем отличается обход дерева в глубину (DFS) от обхода в ширину (BFS)? Назовите виды DFS обходов и их особенности.

- DFS (Depth-First Search / обход в глубину):
    - Сначала идем по одному пути до самого конца (до листа), потом возвращаемся и исследуем другие ветви.
    - Реализуется рекурсивно или с помощью стека.
    - Виды DFS:
        1. Pre-order (узел → левое → правое)
            - Сначала обрабатывается узел, потом поддеревья.
        2. In-order (левое → узел → правое)
            - BST дает элементы в отсортированном порядке.
        3. Post-order (левое → правое → узел)
            - Полезно для удаления дерева или вычисления выражений в деревьях выражений.
- BFS (Breadth-First Search / обход в ширину):
    - Исследует дерево по уровням: сначала корень, потом все узлы первого уровня, затем второго и т.д.
    - Реализуется с помощью очереди.

4. Почему в вырожденном BST (например, когда элементы добавляются в отсортированном
порядке) сложность операций поиска и вставки становится O(n)?

- Если элементы вставляются в отсортированном порядке, каждый новый элемент становится правым потомком предыдущего.
- Дерево превращается в список: каждый узел имеет только одного потомка.
- Высота дерева h = n.
- Поиск элемента требует прохода почти всех узлов → O(n)
- Вставка также требует спуска до конца → O(n)

5. Что такое сбалансированное дерево (например, AVL-дерево) и как оно решает проблему
вырождения BST?

- Сбалансированное дерево — это BST, в котором разница высот левого и правого поддеревьев любого узла ограничена константой.
- Пример: AVL-дерево, где разница высот поддеревьев ≤ 1.

Как решает проблему вырождения:
1. После каждой вставки или удаления проверяется баланс узлов.
2. Если баланс нарушен, выполняются ротации (левые/правые), чтобы дерево оставалось сбалансированным.
3. Высота дерева при n элементах всегда O(log n), поэтому все операции поиска, вставки и удаления выполняются O(log n) даже при добавлении отсортированных данных.