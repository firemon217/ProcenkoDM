# Отчет по лабораторной работе 4
# Алгоритмы сортировки

**Дата:** 2025-10-06
**Семестр:** 3 курс 1 полугодие - 5 семестр
**Группа:** ПИЖ-Б_О-23-1(2)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Проценко Дмитрий Максимович

## Цель работы
Цель работы: Изучить и реализовать основные алгоритмы сортировки. Провести их теоретический и
практический сравнительный анализ по временной и пространственной сложности. Исследовать
влияние начальной упорядоченности данных на эффективность алгоритмов. Получить навыки
эмпирического анализа производительности алгоритмов.

## Теоретическая часть

- Сортировка пузырьком (Bubble Sort): Многократно проходит по массиву, сравнивая и меняя
местами соседние элементы. Сложность: O(n²) во всех случаях.
- Сортировка выбором (Selection Sort): На каждом проходе находит минимальный элемент из
неотсортированной части и ставит его на очередную позицию. Сложность: O(n²).
- Сортировка вставками (Insertion Sort): Построение окончательного массива путем пошагового
вставления каждого элемента в правильную позицию в уже отсортированной части. Сложность:
O(n²) в худшем и среднем, O(n) в лучшем (уже отсортированный массив).
- Сортировка слиянием (Merge Sort): Рекурсивный алгоритм "разделяй и властвуй". Массив
разбивается на две части, которые сортируются рекурсивно, а затем сливаются в один
отсортированный массив. Сложность: O(n log n) во всех случаях. Требует O(n) дополнительной
памяти.
- Быстрая сортировка (Quick Sort): Рекурсивный алгоритм "разделяй и властвуй". Выбирается
опорный элемент, массив разделяется на элементы меньше и больше опорного, которые
сортируются рекурсивно. Сложность: O(n log n) в среднем, O(n²) в худшем случае (плохой выбор
опорного элемента). Сортировка на месте, не требует дополнительной памяти.


Для проведения тестов использовался апарат со следующими комплектующими:
Характеристики ПК для тестирования:
- Процессор: Intel Core i7-12700H @ 2.30GHz
- Оперативная память: 16 GB DDR4
- ОС: Windows 11
- Python: 3.13.1

## Практическая часть

1. Реализовать 5 алгоритмов сортировки.
2. Провести теоретический анализ сложности каждого алгоритма.
3. Экспериментально сравнить время выполнения алгоритмов на различных наборах данных.
4. Проанализировать влияние начальной упорядоченности данных на эффективность сортировок.

### Ключевые фрагменты кода

~~~ python


~~~

## Результаты выполнения

### Пример работы программы



## Ответы на контрольные вопросы

1. Какие алгоритмы сортировки имеют сложность O(n²) в худшем случае, а какие — O(n log n)?
 - O(n²): Bubble Sort, Insertion Sort, Selection Sort, худший случай Quick Sort (при плохом выборе опорного элемента).
 - O(n log n): Merge Sort, Heap Sort, средний случай Quick Sort.

2. Почему сортировка вставками (Insertion Sort) эффективна для маленьких или почти отсортированных массивов?
Потому что она делает минимальное количество операций, когда элементы уже почти на своих местах.
Затраты на сравнения и сдвиги становятся очень малыми, а накладных расходов почти нет.

3. В чем разница между устойчивой (stable) и неустойчивой (unstable) сортировкой? Пример.
Устойчивая сортировка сохраняет относительный порядок элементов с одинаковыми значениями.
Неустойчивая — может менять порядок равных элементов.
Примеры:
Устойчивые: Insertion Sort, Merge Sort, Bubble Sort.
Неустойчивые: Quick Sort, Selection Sort.

4. Опишите принцип работы Quick Sort. Что такое опорный элемент и как его выбор влияет на производительность?
Quick Sort выбирает опорный элемент (pivot), делит массив на две части — меньше pivot и больше pivot — и рекурсивно сортирует части.
Если pivot выбран плохо (например, всегда минимальный/максимальный в почти отсортированном массиве), производительность падает до O(n²).
Хороший pivot даёт усреднённое O(n log n).

5. Когда Merge Sort предпочтительнее Quick Sort?
 - Когда важна стабильность сортировки.
 - Когда данные не помещаются в память (внешняя сортировка).
 - Когда нужна гарантированная сложность O(n log n) независимо от данных.

## Приложения
