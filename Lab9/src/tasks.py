def coin_change_min_coins(coins, target_sum):
    """
    Возвращает минимальное количество монет для суммы target_sum.
    Если сумму собрать нельзя — возвращает -1.

    coins: список номиналов монет
    target_sum: целевая сумма
    """

    # dp[x] хранит минимальное количество монет для суммы x
    # Инициализируем "бесконечностью" — большое число,
    # чтобы можно было искать минимум.
    dp = [float('inf')] * (target_sum + 1)

    # Сумма 0 набирается нулём монет
    dp[0] = 0

    # Перебираем каждую сумму от 1 до target_sum
    for s in range(1, target_sum + 1):

        # Пробуем взять каждую монету
        for coin in coins:
            if s - coin >= 0:
                dp[s] = min(dp[s], dp[s - coin] + 1)

    # Если dp[target_sum] осталось бесконечностью — сумма недостижима
    return dp[target_sum] if dp[target_sum] != float('inf') else -1

def lis_dp(arr):
    """
    Вычисляет длину LIS (наибольшей возрастающей подпоследовательности)
    с помощью классического динамического программирования O(n²).

    arr: входная последовательность чисел
    """

    n = len(arr)
    if n == 0:
        return 0

    # dp[i] — длина LIS, заканчивающейся в позиции i
    dp = [1] * n  # минимальная LIS состоит хотя бы из одного элемента

    # Перебираем каждый элемент как потенциальный конец подпоследовательности
    for i in range(n):

        # Перебираем все предыдущие элементы j < i
        for j in range(i):
            # Если arr[j] < arr[i], то arr[i] можно добавить после arr[j]
            if arr[j] < arr[i]:
                # Обновляем dp[i] — берем максимум из всех вариантов
                dp[i] = max(dp[i], dp[j] + 1)

    # Ответ — максимальное значение dp
    return max(dp)
